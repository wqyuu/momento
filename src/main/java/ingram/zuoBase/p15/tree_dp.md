## 树

如果必须用第三次信息进行强整合，那就要使用`dp套路` 
如果不必须，像中序先序遍历这样， 那就用`morris遍历`


### 树形dp

以左树要信息，右树要信息 分类


#### 二叉树节点间最大距离问题

1.head不参与
- 左树中有最大距离
- 右树中有最大距离
2.head参与
- 左树高度+1+右树高度 ；  1是把head节点距离算上


#### dp套路
第一步：以某个节点x为头结点的子树中，分析答案有哪些可能性，并且这种分析是以x的左子树、X的右子树和x整棵树的角度来考虑可能性的
第二步：根据第一步可能性分析，列出所有需要的信息
第三步：合并第二步信息，对左树和右树提出同样的要求，并写出信息结构
第四步：设计递归函数，递归函数是处理以x为头节点的情况下的答案。
包括设计递归basecase，默认直接得到左树和右树的所有信息，以及把可能性做整合，并且返回第三步的信息结构


#### 例子： 派对的最大快乐值
！基本条件：上级发请柬直接下级不能来

1.可能性分类
X参与、X不参与


X参与
x乐+a整棵树a不来最大快乐+b整棵树b不来最大快乐+c整棵树c不来最大快乐

X不参与
0+max(a来整棵树最大快乐,a不来整棵树最大快乐)+ max(b来,b不来)+max(c来，c不来)


2.列出所有需要的信息
子树来整棵树最大快乐，子树不来整棵树最大快乐

3.

4.basecase
x是最基层员工，来：x自己 不来: 0

求X不是基层员工 参与、不参与
返回 来/不来 两个数据