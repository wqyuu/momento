排序算法：快速排序、归并排序、堆排序、插入排序、选择排序等；
搜索算法：深度优先搜索（DFS）、广度优先搜索（BFS）、二分查找、回溯等；
动态规划算法：最长公共子序列（LCS）、最大子序和、爬楼梯、背包问题等；
贪心算法：跳跃游戏、根据身高重建队列、买卖股票的最佳时机等；
数学算法：求素数、求快速幂、求最大公约数、求最小公倍数等；
字符串匹配算法：KMP、BM、暴力匹配等；
图论算法：最短路径算法（Dijkstra、Floyd）、拓扑排序、最小生成树算法（Kruskal、Prim）等；
线性数据结构：队列、栈、链表、数组、哈希表等；
树和二叉树：二叉搜索树、AVL树、堆、红黑树等；
经典算法：扫描线算法、插头DP、并查集等。



快速排序 - 题号：56、75、88、215
归并排序 - 题号：21、23、148、349
堆排序 - 题号：1046、215、347、973
插入排序 - 题号：147、148
选择排序 - 题号：215、347
DFS - 题号：17、39、46、79
BFS - 题号：102、107、127、130
二分查找 - 题号：33、34、74、278
回溯 - 题号：17、22、46、79
LCS - 题号：516、1143
最大子序和 - 题号：53、121、152、437
背包问题 - 题号：01背包、完全背包、多重背包
贪心算法 - 题号：55、121、122、860
求素数 - 题号：204、263、357
求最大公约数 - 题号：504、878、914、1025
KMP算法 - 题号：28、214、459
BM算法 - 题号：28、214、459
最短路径算法 - 题号：743、787、882、1631
拓扑排序 - 题号：207、210、329、802
Kruskal算法 - 题号：1135、1168、1584、1631
Prim算法 - 题号：1504、1584、1631
数组 - 题号：1、11、15、167
队列 - 题号：542、994
栈 - 题号：20、32、71、224
链表 - 题号：2、24、25、206
哈希表 - 题号：1、15、49、202
二叉搜索树 - 题号：98、 230、235、236
AVL树 - 题号：110、543、1123
堆 - 题号：215、295、373
扫描线算法 - 题号：223、850、850、218
插头DP - 题号：1240、1494、1520
并查集 - 题号：547、684、1319


以下是与单调栈有关的几道LeetCode题目：
每日温度 (Daily Temperatures)
https://leetcode-cn.com/problems/daily-temperatures/

最大矩形 (Maximal Rectangle)
https://leetcode-cn.com/problems/maximal-rectangle/

接雨水 (Trapping Rain Water)
https://leetcode-cn.com/problems/trapping-rain-water/



移掉K位数字 (Remove K Digits)
https://leetcode-cn.com/problems/remove-k-digits/



链表中的下一个更大节点 (Next Greater Node In Linked List)
https://leetcode-cn.com/problems/next-greater-node-in-linked-list/




ejvta3


Manacher

求解 最长回文字串长度

重要概念：每个位置最长回文半径

abc1[232]0de1

经典方法
122131221 直接找每个位置两边往外扩，找不到偶数回文，使用#

#1#2#2#1#3#1#2#2#1#


窗口运动

R右；L右  L不超过R


R往右表示有个数字进窗口了


双端队列

 <- -> [                ] <- -> →  ←
       头    大——> 小  尾 
 
  窗口最大值为头部所代表的的值，扔掉数据永远不找回
  
R往右 双端队列更新

L往右 双端队列更新

--------------------------------------------------------------------------------

单调栈 左右两边比该数大的最近的数 栈从上到下，从小到大|

无重复值：栈从上到下的数字保持规则从小到大，当有b>a，且序列为bac, 依次进入到栈中。b进入之前无数字略过，a进入判断b>a,符合规则继续，c进入判断a<c，不符合规则，
a弹出，此时a的左边最大值为b(弹出前栈中上一个数字)，右边最大值为c(当前值)。继续判断c与b大小，若c>b，b弹出左边最大值为null,右边最大值也为c。序列中无数据，最后c弹出，左最大null，右最大null。
为什么这个流程是对的，当b进入a进入时，中间如果有数字，只可能是比a小被弹出了

	| |   
    | |
小	|a|
↑   |b|
大	---    

例：1024 
1,0进入，
2进入，弹出0，左大1右大2.弹出1，左大null右大2; 
4进入，弹出2，左大null右大4; 
无数据，弹出4，左大null右大null;
栈图：
	| |   | | 	| |    | | 
    | |   | |   | |    | |
  	|0|   | |	| |    | |
    |1|   |2|   |4|    | |
  	---   --- 	---    --- 


有重复值：下标压在一起

取链表最后一个值

|       |
|{2,3}  |
|{1}    |
|{0,4,6}|
—--------

Stack<linkedlist<int>>

单调栈例题：数组中累加和与最小值的乘积，假设叫指标A。给定一个数组，
返回子数组中，指标A最大的值。
找某个数，左右两边第一个比该数小的值，为左右两边界，例如5的边界为4,2；
3边界为null,1;  6->1,4;   4->1,2



[3,1,6,4,5,2]

小->大
||
|4|
|6|
|1|
—-

3 9
1 21
6 36
4 60
5 25
2 34


3 9
6 24

sum:3,4,10,14,19,21



--------------------------------------------------------------------------------

树形dp

以左树要信息，右树要信息 分类


二叉树节点间最大距离问题

1.head不参与
- 左树中有最大距离
- 右树中有最大距离
2.head参与
- 左树高度+1+右树高度 ；  1是把head节点距离算上


二叉树套路
第一步：以某个节点x为头结点的子树中，分析答案有哪些可能性，并且这种分析是以x的左子树、X的右子树和x整棵树的角度来考虑可能性的
第二步：根据第一步可能性分析，列出所有需要的信息
第三步：合并第二步信息，对左树和右树提出同样的要求，并写出信息结构
第四步：设计递归函数，递归函数是处理以x为头节点的情况下的答案。
包括设计递归basecase，默认直接得到左树和右树的所有信息，以及把可能性做整合，并且返回第三步的信息结构

派对的最大快乐值
上级发请柬直接下级不能来

1.可能性分类
X参与、X不参与


X参与
x乐+a整棵树a不来最大快乐+b整棵树b不来最大快乐+c整棵树c不来最大快乐

X不参与
0+max(a来整棵树最大快乐,a不来整棵树最大快乐)+ max(b来,b不来)+max(c来，c不来)


2.列出所有需要的信息
子树来整棵树最大快乐，子树不来整棵树最大快乐

3.

4.basecase 
x是最基层员工，来：x自己 不来: 0

求X不是基层员工 参与、不参与
返回 来/不来 两个数据



--------------------------------------------------------------------------------
Morris遍历--m

遍历二叉树的方式，时间复杂度O(N),额外空间复杂度O(1)
通过利用原树中大量空闲指针的方式，达到节省空间的目的

>线索二叉树


先序：【第二次到达不打印】只一次，打印；二次，第一次打印

中序: 只一次，打印；二次，第二次打印

后序：二次，逆序打印右边界，然后单独逆序打印右边界


12.5 
8/4.5



--------------------------------------------------------------------------------
大数据量题
哈希函数分流* 万能 

有一个包含100亿个URL的大文件
url词频大根堆
先分为一堆文件，大根堆统计出每个小文件中的排行，合并为一个大根堆，前一百排行

[{A:100,K:96,FC:87...},{甲:103,乙:90,丙:86},{}....]

[(甲,103),(A,100)...]
 (一)    （二）



int -2^31 -- 2^32
1G = 2^30 


异或：无进位相加
与：

13： 01101
7：  00111

^:   01010
&<<1:01010






--------------------------------------------------------------------------------
动态规划优化

486


象棋，马从(0,0)位置出发，到(x,y)位置，跳K步，方法数









--------------------------------------------------------------------------------
1）热门云平台工具调研
5-6个技术概念

2）开源对应产品




--------------------------------------------------------------------------------
BST

有序表
O(logN)
AVL树 SB 

平衡树

搜索二叉树的增删改查
查 左右遍历
删 找到右树最左节点无左子节点的，把它的右子节点给父节点，把它换到头节点，头节点弹出

搜索二叉树+左旋右旋 -> AVL树 + 怎么用 -> 红黑树/SB树

SB树： RR LL RL LR四种进行调整 

红黑树就是为了从头到尾的最长最短之间最多是一倍，从而平衡
最短是黑树 最长是红黑相间
- 头和叶(null) 黑
- 红点不相邻
- cur当前头，每条到叶(null)的黑点数量相同

跳表：随机概率 0.5-0 0.5-1 




--------------------------------------------------------------------------------
zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz

滑动窗口
打表法：输入整数，输出整数，先写出暴力求解，再找规律打表。4成以上题
预处理数组/预处理结构

滑动窗口最大值最小值更新结构

绳子最多覆盖多少点
- 二分O(N*logN)
- 滑动窗口 O(N) 单调不递减确定终点 不回退模型

1 2 3 4 5 7 8 10
0 1 2 3 4 5 6 7
        L m  
        R

v = 5
R = 7
L = 0
index = 5

### 打表法 ### 
装苹果
6/8个苹果的袋子
买n个苹果，最少使用袋子。不能正好装下，返回-1


吃草
1 4 16 64
N

先手 
后手

65  
rest =N%4
N - rest 
a += 
b

### 预处理结构 ###
11111110
10011111
11111111
11100110
11100110
11111110


O(N平方) 找到多少个正方形？复杂度：O(N立方)

for(col){
 for(row){
   for(border = 0; border< min(col-N,row-M);border++){
       // 判断边是不是都是1
    } 
 }
}

预处理结构，设置个 right 矩阵计算每个点包含自己右方有多少个连续的1
再设置个down 矩阵计算每个点包含自己下方有多少个连续的1

看左上角点 右侧是不是有border个连续的1 -- right
看左上角点 下侧是不是有border个连续的1 -- down
跳到右上角  下侧是不是有border个连续的1 -- down
跳到左下角  右侧是不是有border个连续的1 -- right



--------------------------------------------------------------------------------
zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
动态规划


1.N个节点，多少种树


2.括号串 是否完整，需要补充多少会完整

左->右 遍历 count=0
ANS = 0
( c++
) c -- 
if(count=-1){
	ANS ++
	补上左括号
}



[3,2,5,7,0,0] k=2
找到差值为2的数据
去重 (0,2) (3,5) (5,7)


zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
业务/技巧

贪心
两个集合，让两个集合平均，进行多次magic。求最多次数




zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz


合法的括号，能达到的最大深度是多少

if(c='(') count++ else count -- 

给一个字串，求最长连续有效括号的长度

例如： ())()(()))()))(())   ----> 结果为8 


每个位置都求一个最长的字串，总最长就在其中
通过dp求解

())()(()))()))(())
0123456789101112131415

dp[020                      ]
dp[i]: 字串必须从i位置字符结尾，最长的有效长度是多少



zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
无序栈，给一个辅助栈，来回倒，导出有序从大到小

设置 辅助栈 必须从小到大


zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz

从左往右尝试模型



zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
树形dp
二叉树每个结点都有一个int型权值 ，给定一颗二叉树，要求计算出从根结点到叶结点的所有路径中，权值和最大的值为多少



zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
正方模型
从右向左

1.给定一个元素为非负整数的二维数组matrix，每行都是从小到大有序的。 再给定一个非负整数aim，请判断aim是否在matrix中。
第一行x,y,表示矩阵行列数 x,y<=3000
随后x行y列，表示矩阵数据，每一行都是从小到大有序。m[i][ii]<=1e9
最后一行一个数aim，大小不限

123
457
689

思路：从最右上角开始找,大于aim向下，小于向左
例如从上面矩阵找8，路径为3->7->9->8 
步骤
- 3小于8， 向下到7
- 7小于8，向下到9
- 9大于8，向左，找到8
如果是找10，从上到下最后越界都未找到，说明没这个数字。

2.给定一个元素为非负整数的二维数组matrix，存在01时，左面都是连续0，右面都是连续1，
寻找最多1个数的行，有多少个1

000000111
000000011
000011111
001111111

思路：从最右上角开始找,为1就向左继续移动，设置个数ans值增加，直到碰到0,走不了，向下寻找，下面是0，则继续向下，碰到1向左找，设置个数ans值继续增加，循环这个过程，最后输出ans


--------------------------------------------------------------------------------
贪心策略 业务题







zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
矩形打印

宏观调度过程

zigzag

a b c d e 
f g n i j 
h k l p o                      

A 0,0 
B 0,0 


a fb cgh knd eil pj o 


zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
(1)统计一堆字串中，出现次数前K的字符串。
词频表
- 大根堆
- 小根堆，heapfiy，heapInsert

(2)设计一个结构：
- 接收字符串
- 当前top K

需要使用如下三个子结构：
- 词频表(key字符串，value词频)
- 堆p[初始k长度] HeapSize = 0 
- 堆位置 map (k: 字符串  v: 堆位置)




有序表

边界判断题

前缀树 深度优先遍历
目录结构打印


二叉树套路

最大二叉搜索子树的头

X无关 
  左 maxBstHead   
  右 maxBstHead 

X有关 
  左搜 & 右搜 & 左最大< x & x < 右最小
  
  
假设答案法  

压缩数组


--------------------------------------------------------------------------------
贪心策略

最少路灯

递归

求完全二叉树节点个数

- 右树最左节点到不到最后一层
  - 到最后一层，代表左树是满的 2^左树高度 + 右树个数 
  - 没到 ，右树是满的，2^右树高度 + 左树节点个数

递归上述过程↑




### 最长递增子序列

#### 方法1
arr [3,1,2,6,3,4,0]
i    0 1 2 3 4 5 6 

dp  [1 1 2 3 3 4 1 ]
j    0 1 2 3 4 5 6 
dp[j]  --> 子序列必须从arr[i]结尾下最长长度

O(N^2)

#### 方法2


arr   [3,2,4,5,1,7]
i      0 1 2 3 4 5 


i = 0       
dp    [1 ]
j      0 
      
ends  [3 ]    
       0 1 2 3 4 5     

i = 1,ends  arr[1]值为2，比ends[0]小 ，将0位置更新为2，ends里面有几个数字，就是dp里的数，如果比ends里数大，那就扩充

dp    [1 1]
j      0 1
      
ends  [2 ]    
       0 1 2 3 4 5   



	   
i = 2 ， 4>2 扩充ends数组，[2,4]
dp    [1 1 2]
j      0 1 2
      
ends  [2 4 ]    
       0 1 2 3 4 5   

... 	   
dp    [1 1 2 3 1 4]
j      0 1 2 3 4 5
      
ends  [1 4 5]    
       0 1 2 3 4 5 

	   
ends[i] 有效，表示所有长度为i+1的递增子序列中最小结尾



### 小Q得到一个神奇的数列： 1,12,123,...12345678910,123456789101112...

小Q得到一个神奇的数列: 1, 12, 123,…12345678910,1234567891011…。
并且小Q对于能否被3整除这个性质很感兴趣。
小Q现在希望你能帮他计算一下从数列的第l个到第r个(包含端点)有多少个数可以被3整除。
输入描述:
输入包括两个整数l和r(1 <= l <= r <= 1e9), 表示要求解的区间两端。
输出描述:
输出一个整数, 表示区间内能被3整除的数字个数。






--------------------------------------------------------------------------------


二叉树的递归套路
递归找动态规划套路
树形dp

